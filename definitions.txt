ЛИНЕЙНАЯ АЛГЕБРА

Матрицы

Матрица — это прямоугольная таблица, образованная из эле-
ментов некоторого множества и состоящая из m строк и n
столбцов.

Если m = n , то матрица называется квадратной, а число m = n — ее по‐
рядком

Матрицы A и B одного размера называются равными, если они со-
впадают поэлементно, т. е. a ij = b ij для любых i = 1 , m ; j = 1 , n .

Квадратная матрица, у которой все элементы, кроме элементов глав-
ной диагонали, равны нулю, называется диагональной.

Диагональная матрица, у которой каждый элемент главной ди-
агонали равен единице, называется единичной и обозначается буквой
Е или I.

Матрица, все элементы которой равны нулю, называется нулевой
и обозначается буквой О.

Квадратная матрица называется верхней треугольной, если все эле-
менты, расположенные ниже главной диагонали, равны нулю.

Квадратная матрица называется нижней треугольной, если все эле-
менты, расположенные выше главной диагонали, равны нулю.

Матрица, содержащая один столбец или одну строку, называет-
ся вектором (вектор-столбцом или вектор-строкой соответственно).

Матрица, полученная из данной заменой каждой ее строки столбцом
с тем же номером, называется матрицей, транспонированной к данной.

Квадратная матрица А называется симметрической, если она совпа-
дает со своей транспонированной, то есть
А = А Т .

Квадратная матрица А называется кососимметрической, если совпа-
дает со своей транспонированной, умноженной на число (–1), то есть
А = –А Т .

Для квадратной матрицы А порядка n введем числовую характери-
стику, называемую определителем или детерминантом.
Обозначение: det A, или |A|, или Δ.

Минором элемента a ij определителя n‐го порядка называется опре-
делитель ( n -1 ) -го порядка, полученный из исходного путем вычерки-
вания строки и столбца, на пересечении которых стоит данный эле-
мент.

Алгебраическим дополнением элемента a ij определителя называется
минор, взятый со знаком «плюс», если сумма ( i + j ) — четное число,
и со знаком «минус», если эта сумма начетная.

Определитель равен сумме произведений элементов некоторого
ряда на соответствующие им алгебраические дополнения

Сумма произведений элементов какого-либо ряда определителя
на алгебраические дополнения соответствующих элементов парал-
лельного ряда равна нулю.

Квадратная матрица А называется невырожденной (неособенной),
если определитель матрицы А не равен нулю, т. е.
det A No 0 .

Невырожденная матрица, умноженная на обратную матрицу дает
единичную квадратную матрицу.


Присоединенная матрица — это матрица, составленная из алгебраи-
ческих дополнений данной матрицы и транспонированная.

Элементарными преобразованиями матрицы являются:
1) перестановка строк (столбцов);
2) умножение строки (столбца) на число, отличное от нуля;
3) прибавление к элементам строки (столбца) соответствующих эле-
ментов другой строки (столбца), предварительно умноженных на неко-
торое число.

Ранг матрицы — максимальный порядок отличных от нуля мино-
ров матрицы А.

Любой минор порядка r (r — ранг матрицы), отличный от нуля, на-
зывается базисным минором.

Свойства ранга
1. При транспонировании матрицы ее ранг не изменяется.
2. Если вычеркнуть из матрицы нулевой ряд, то ранг матрицы не из-
менится.
3. При элементарных преобразованиях матрицы ее ранг не изме-
няется.
Матрицы А и B называются эквивалентными, если r ( A ) = r ( B ).

Две строки матрицы называются равными, если равны их соответ-
ствующие элементы: e k = e s , если a kj = a sj , j = 1 , 2 ,  n .


Теорема о ранге матрицы. Ранг матрицы равен максимальному числу
ее линейно независимых строк или столбцов, через которые выражают‐
ся все остальные ее строки (столбцы).


Системы линейных уравнений


Система уравнений называется совместной, если она имеет хотя бы
одно решение.

Система уравнений называется несовместной, если она не имеет
ни одного решения.

Совместная система называется определенной, если она имеет един-
ственное решение.

Совместная система называется неопределенной, если она имеет бо-
лее одного решения.

Каждое решение неопределенной системы называется частным ре‐
шением этой системы.

Совокупность всех частных решений называется общим решением
системы.


Главные (базисные) неизвестные — неизвестные, коэффициенты ко-
торых входят в базисный минор.

Свободные неизвестные — это n - r неизвестных, коэффициенты ко-
торых не входят в базисный минор.



ДИСКРЕТНАЯ МАТЕМАТИКА
Теория множеств

Множество состоит из элементов – деревьев, студентов, бедных родственников… При этом никакой роли не играет, рассматриваем ли мы тех же студентов в порядке алфавита или по успеваемости.
Недопустимы только двойники или студенты, у которых отсутствуют отличительные свойства.

Второе базовое понятие – это ПРИНАДЛЕЖНОСТЬ (или «отношение принадлежности»). То есть «элемент принадлежит множеству». В обыденной речи можно заменить "принадлежит" на:
– Та березка «находится» в этом лесу,
– Сидоров «числится» в студентах,
– Мистер Х «входит» в число ваших бедных американских родственников.

«принадлежит» относится к случаю, когда "ЭЛЕМЕНТ принадлежит МНОЖЕСТВУ", а «включено» – когда "МНОЖЕСТВО включено в МНОЖЕСТВО".

Любой элемент, принадлежащий множеству, не содержащему ни одного элемента, принадлежит и любому другому множеству, которое не содержит ни одного элемента.

Любое множество является собственным подмножеством.

теория множеств оперирует со всеми множествами, кроме тех, которые нельзя создать. Все эти множества, об'единенные в одно множество, называются УНИВЕРСУМОМ.

Мощность – это то что остается, когда нас не интересует сущность элементов множества и порядок, в котором они располагаются.

Множество натуральных чисел по Кантору. Это множество бесконечное. Кантор назвал это множество СЧЕТНЫМ и его мощность – мощностью счетного множества.

если взять бесконечное множества счетной мощности, например, множество целых положительных чисел и построить (разумеется, умозрительно) множество, содержащее в качестве элементов все подмножества этого множества, то получим мощность БОЛЬШУЮ, чем счетная мощность. В принципе не существует способа пересчитать (пусть в бесконечности) такое множество. В нем всегда больше элементов. Эта новая большая мощность называется мощностью КОНТИНУУМА.

Основные операции над множествами:
Операции называются ОБ'ЕДИНЕНИЕ, ПЕРЕСЕЧЕНИЕ и ДОПОЛНЕНИЕ.

В алгебре множеств есть те же названия законов: КОММУТАТИВНЫЙ, АССОЦИАТИВНЫЙ и ДИСТРИБУТИВНЫЙ (перестановочный, сочетательный и распределительный).

Коммутативный закон: Об'единение (пересечение) отличников и спортсменов равно об'единеию (пересечению) спортсменов и отличников.

Ассоциативный закон: От изменения порядка об'единения (пересечения) спортсменов, отличников и красавцев результат не меняется.

Дистрибутивный закон (только экзотическая версия): Об'единение красавцев с пересечением спортсменов и отличников равно множеству, в котором пересекаются об'единения красавцев и спортсменов с об'единеием красавцев с отличниками. (В условных обозначениях это было бы гораздо короче и нагляднее, но мы зареклись насчет формул).

Закон поглощения (пример) - Пересечение отличников с об'единением отличников и спортсменов дает множество отличников.

закон ИДЕМПОТЕНТНОСТИ. Об'единение (пересечение) множества спортсменов с множеством спортсменов дает множество спортсменов.

ЗАКОН Де Моргана: Дополнение об'единения отличников со спортсменами равно пересечению дополнения множества спортсменов с дополнением множества отличников.

закон ДВОЙНОГО ДОПОЛНЕНИЯ. Дополнение дополнения множества спортсменов есть само множество спортсменов. 

Самыми экзотическими являются два закона: ПРОТИВОРЕЧИЯ и ИСКЛЮЧЕННОГО ТРЕТЬЕГО.
Противоречия: Пересечение множества спортсменов с дополнением множества спортсменов пусто.

Исключенного третьего: Об'единение множества спортсменов с дополнением множества спортсменов совпадает с рассматриваемым универсумом. 

между множествами могут устанавливаться различные СООТВЕТСТВИЯ и ОТНОШЕНИЯ.

Глядя на многочисленные примеры вокруг мы замечаем, что для определения конкретного соответствия надо определить два множества: множество (область) определения
и множество (область) значений. А также определить «пары соответствий». Например, область определения – группа ух-005, сдающая экзамен; область значений
– отл, хор, уд, неуд – множество оценок.
И множество пар Иванов – отл, Петров – хор, Сидоров – отл. А Хведоров – не явился. Вот вам и готовое соответствие.

Соответствия обладают свойствами.
1. В данном случае соответствие НЕ-ВСЮДУ-ОПРЕДЕЛЕННОЕ, поскольку для Хведорова в этом соответствии нет пары. (Даже если бы мы написали в ведомости Хведоров – н/я, то это все равно бы не попало в соответствие, поскольку «н/я» нет в множестве допустимых значений!). Если бы деканат своевременно исключил из ведомости Хведорова, как отчисленного, то это соответствие стало бы ВСЮДУ-ОПРЕДЕЛЕННЫМ
2. Соответствие ФУНКЦИОНАЛЬНО, поскольку каждому студенту соответствует не более одной оценки. Такое соответствие называют по-простому, ФУНКЦИЕЙ. В данном случае из-за Хведорова это не всюду определенная функция. Никакой разницы со школьной функцией кроме той принципиальной, что здесь аргументами и значениями могут быть не только числа, а любые об'екты. Кстати, не всем математикам нравится такое определение функции, хотя оно абсолютно строгое. Просто сказывается ревность к множествам с позиций некоторых других разделов математики.
Если бы за один экзамен студенты могли получать несколько оценок, то соответствие было бы НЕФУНКЦИОНАЛЬНЫМ.

3. Данное соответствие НЕИН'ЕКТИВНО, поскольку отл получил более, чем один студент.
В инъекции первое множество меньше или равно второму по числу элементов

4. Данное соответствие НЕСЮР'ЕКТИВНО,

в сюръекции второе множество исчерпывается первым и каждый элемент второго может быть поставлен в соответствие нескольким элементом первого

5. Соответствие, которое одновременно ВСЮДУ-ОПРЕДЕЛЕНО, ФУНКЦИОНАЛЬНО, ИН'ЕКТИВНО и СЮР'ЕКТИВНО называется БИЕКТИВНЫМ

ОТНОШЕНИЯ отличаются от соответствий тем, что определяются на одном множестве.

Отношения, в силу специфики, характеризуются иным перечнем свойств, нежели соответствия.
1. РЕФЛЕКСИВНОСТЬ. Это когда отношение обращено на себя. 
Если верить народной мудрости, то и отношение «спасения» на множестве утопающих – рефлексивно.

2. АНИТИРЕФЛЕКСИВНОСТЬ. Это когда отношение к самому об'екту (всегда) неприменимо. Например, «перпендикулярность» на множестве прямых. Прямая не может быть перпендикулярна самой себе.

3. СИММЕТРИЧНОСТЬ. Если Иванов «учится в одной группе» с Петровым, то и обратное справедливо. Если прямая А «перпендикулярна» прямой B, то и обратное справедливо.

4. АНТИСИММЕТРИЧНОСТЬ. Если тысячу рублей можно «разменять» сотнями, то обратное не под силу даже фокуснику. 

5. ПОЛНОТА. Это свойство прежде всего «направлено» на само множество. Полнотой обладает отношение, которое для любой пары разных элементов данного множества выполнимо хотя бы «в одну сторону». Например, полнотой обладает отношение «больше» для множества действительных чисел, ибо для двух разных действительных чисел одно обязательно больше другого.

6. ТРАНЗИТИВНОСТЬ. Если Иванов «учится в одной группе» с Петровым, а Петров с Сидоровым, то Иванов «учится в одной группе» с Сидоровым. Отношение включения тоже транзитивно.

Если это соответствие к тому же еще и всюду-определено, то оно называется ОТОБРАЖЕНИЕМ.


Каждое конкретное отношение обладает сразу совокупностью свойств. Полезно исследовать группы отношений, у которых совокупности свойств одинаковые.

Прежде всего к таковым относятся отношения ЭКВИВАЛЕНТНОСТИ. Это отношения, которые одновременно обладают свойствами рефлексивности, симметричности и транзитивности.

Заметную роль в математике играют и отношения ПОРЯДКА, обладающие свойствами транзитивности и антисимметричности. 

Дополнительно, если порядки обладают свойством полноты, то их называют СОВЕРШЕННЫМИ. Например, «больше», на множестве действительных чисел.
Если отношение еще и рефлексивно, то порядок называют НЕСТРОГИМ (ЧАСТИЧНЫМ).

Отношения, похожие на отношения порядка, но не обладающие свойством транзитивности, называют отношениями ТОЛЕРАНТНОСТИ.

Отношения частичного порядка, то есть рефлексивные, антисимметричные и транзитивные, на которые накладывают ряд дополнительных свойств, изучаются в рамках раздела математики с экзотическим названием ТЕОРИЯ РЕШЕТОК.

Для определения решетки договоримся называть элемент НАИБОЛЬШИМ (НАИМЕНЬШИМ), если он больше (меньше) любого другого элемента частично-упорядоченного множества – кратко ЧУМ. 

МАКСИМАЛЬНЫМ (МИНИМАЛЬНЫМ) называется элемент ЧУМ, больше (меньше) которого в этом множестве нет элементов.

Если, далее, возьмем множество студентов потока и наведем в нем частичный порядок. Имеется в виду не «всеми доступными средствами», а лишь отношением «учится лучше (или одинаково)», считая, что ради такого дела можно для любых двух студентов решить, который лучше… Из этого множества выделим группу ух-005 и найдем студентов потока, которые учатся лучше всех студентов группы ух-005. То есть найдем на потоке студентов, «наибольших» для этой группы. Таких студентов может оказаться несколько, если только «наибольший» студент группы не является одновременно наибольшим элементом всего потока. Такое множество наибольших элементов называется множеством МАЖОРАНТ. Рассматривая наименьших студентов, получим множество МИНОРАНТ. А теперь в самом множестве мажорант (минорант) найдем наименьший (наибольший) элемент

Такие элементы называются соответственно СУПРЕМУМ и ИНФИМУМ. Или кратко, sup и inf.


ТЕОРИЯ ГРАФОВ

Граф – это множество вершин V и множество рёбер E, содержащих упорядоченную пару G=(V, E).

Объекты называются вершинами и отмечаются точка-
ми, а связи между вершинами называются дугами и отмечаются стрелками
между соответствующими точками

Путь Эйлера конечного неориентированного графа G(V, E) является таким путём, что каждое ребро G появляется на нём один раз. Если G имеет путь Эйлера, то он называется графом Эйлера.

Конечный неориентированный связный граф – это граф Эйлера тогда и только тогда, когда ровно две вершины имеют нечётную степень, или все вершины имеют чётную степень.

Конечный граф – граф с конечным количеством рёбер и вершин.

Бесконечный граф – граф, конец которого в определённом направлении(ях) простирается до бесконечности.

Неориентированный граф – граф, рёбра которого не имеют определённого направления.

Ориентированный граф – граф, рёбра которого имеют определённое направление.

Связный граф – граф, в котором отсутствуют недостижимые вершины (вершины, не связанные с остальными).

Несвязный граф – граф, в котором существуют недостижимые вершины.

Мультиграф В теории графов мультиграфом (или псевдографом) называется граф, в котором разрешается присутствие кратных рёбер (их также называют «параллельными»), то есть рёбер, имеющих те же самые конечные вершины.

Порождённый подграф графа — это другой граф, образованный из подмножества вершин графа вместе со всеми рёбрами, соединяющими пары вершин из этого подмножества.

Маршрут
(walk) -
это "способ перехода из одной вершины в другую" в гра­фе или ориентированном графе, состоящий из последовательности ребер или
дуг, следующих одна за другой.

Маршрут вида Q-s-т-Q, в
котором ни одна вершина не появляется более одного раза, за исключением со­
впадающих начальной и конечной вершин, называется циклом
(cycle).


объект с разрешенными циклами и кратными ребрами называется
обобщенным графом
(genera\ graph)
или просто графом

каждый простой граф является графом, но не каждый граф яв­
ляется простым.

Два графа G1 и G2 ИЗОМОРФНЫ, если существует взаимно однозна-
чное соответствие между вершинами G 1 и вершинами G 2, такое, что число
ребер, соединяющих любые две вершины G 1, равно числу ребер, соединяющих
соответствующие вершины G 2


Мы говорим, что две вершины графа,
v и w, являются смежными (adjacent),
v и w называют­
если существует соединяющее их ребро vw; тогда вершины
ся инцидентными
(incident)
такому ребру. Мы таюке говорим, что два раз­
ных ребра, е иf, являются смежными
(рис.
(adjacent),
если имеют общую вершину

Степень вершины - число ребер, инцидентных этой вершине (deg(v))
Обычно считают, что петля вносит 2 единицы в степень, а не 1


Верши­на степени О представляет собой изолированную вершину, а вершина степени 1 - конечную.

Последовательность степеней графа состоит из степеней, записанных в по­
рядке возрастания, при необходимости с повторениями.

(лемма о рукопожатиях). В любом графе сумма всех степе­ней вершин является четным числом.

Следствие леммы:
В
любом графе количество вершин с нечетной степенью
четно.


Граф Н является подграфом графа G если каждая из его вершин принад­ лежит V(G), а каждое его ребро принадлежит E(G).

Дополнение графа (обратный граф) — граф 'G', имеющий то же множество вершин, что и заданный граф G, но в котором две несовпадающие вершины смежны тогда и только тогда, когда они не смежны в G.


Матрица смежности графа G с конечным числом вершин n (пронумерованных числами от 1 до n) — это квадратная матрица A размера nxn, в которой значение элемента a{i,j} равно числу рёбер из i-й вершины графа в j-ю вершину.

Матрица инцидентности — одна из форм представления графа, в которой указываются связи между инцидентными элементами графа (ребро(дуга) и вершина). Столбцы матрицы соответствуют ребрам, строки — вершинам. Ненулевое значение в ячейке матрицы указывает связь между вершиной и ребром (их инцидентность).


Граф с пустым множеством ребер называется нулевым гра­
фом(null graph); обратите
внимание, что каждая вершина нулево­
го графа изолирована. Обозначается Nn

Полным графом
(co111plete graph)
называется простой граф, в котором ка­
ждая пара различных вершин смежна. Обозначается Kn

Связный граф, в котором каждая вершина имеет степень 2, называется
циклическим графом Обозначается Cn


Граф, полученный из С, путем удаления ребра, называется цепью
(path graph) и обозначается как Рn

Граф, полученный из С"_ 1 путем соединения каждой вершины с новой вер­
шиной v, называется колесом (wheel) сп вершинами и обозначается как Wn.


Граф, в котором каждая вершина имеет одну и ту же степень, называется
регулярным графом
(regular graph). Если каждая вершина имеет степень r,
граф является регулярным степени r, или r-регулярным.
Обратите внима­ние, что нулевой граф является регулярным графом степени О, циклический - 2, а полный граф является ре­гулярным графом степени n-1.


Куби́ческий граф — граф, в котором все вершины имеют степень три. Другими словами, кубический граф является 3-регулярным. Кубические графы называются также тривалентными.

Среди регулярных графов интерес представляют Платоновы графы, обра­
зованные из вершин и ребер пяти правильных (платановых) тел
октаэдра, гексаэдра, икосаэдра и додекаэдра

Если множество вершин графа G
можно разбить на два непересекающих­
ся множества, А и В, так, чтобы каждое ребро G соединяло вершину из А и
вершину из В, то G является двудольным графом
(blpartite graph)


Полный двудольный граф (биклика) — специальный вид двудольного графа, у которого любая вершина первой доли соединена со всеми вершинами второй доли вершин.


Мы также можем определить связность ориентированных графов. Ориенти­
рованный граф D
является (слабо) связным, если он не может быть представ­
лен как объединение двух орграфов, определенных очевидным образом.

Полустепень исхода из вершины v равна количеству дуг вида vw, обозначается как outdeg(v).

Полустепень захода - indeg(v)  = количеству дуг вида wv.


(орлемма о рукопожатиях). В
любом графе сумма всех полу­
степеней исхода равна сумме всех полустепеней захода.

Бесконечный граф V( G)
(infinite graph) G состоит из бесконечного множества
элементов, именуемых вершинами, и бесконечного семейства Е( G) не­
упорядоченных пар элементов V(G), именуемых ребрами. Если V(G)
и E(G) являются счетными бесконечными множествами (т.е. могут быть маркированы как 1, 2, 3,".),то G является счетным графом (countaЫe

Степень вершины
мощностью множества ребер, инцидентных
v,
v
бесконечного графа является
и может быть конечной или бес­
конечной.

Бесконечный граф локально конечен (locally
finite),
если каждая
из его вершин имеет конечную степень;


Каждый связный локально счетный бесконечный граф яв­
ляется счетным графом.

Каждый связный локально конечный бесконечный граф
является счетным графом.

Разделяющее множество
(disconnecting set)
в связном графе представ­
ляет собой множество ребер, удаление которых делает граф
G несвязным.


разрез
(cutset)
-
минимальное разделяющее множе­
ство, т.е. разделяющее множество, никакое собственное подмножество кото­
рого не является разделяющим множеством.


Если разрез содержит только одно ребро е, то мы называем его мостом
(bridge)
или перешейком

Если G является связным графом, то его реберная связность ( edge-connec-
tivity) A(_G) равна размеру наименьшего разреза в G.

Можно также определить аналогичные понятия для удаления вершин. Раз­
деляющее множество
(separating set)
в связном графе представляет собой
множество вершин, удаление которых делает
G
несвязным.


Если разделяющее множество содержит только 1 вершину, мы называем
такую вершину - разрезающей вершиной (cut vertex)


Связный граф G является ориентируемым тогда и только
тогда, когда каждое ребро
G принадлежит по крайней мере одному циклу.

Пусть G- связный
локально конечный бес­
конечный граф. Тогда для любой его вершины
ний бесконечный путь с начальной
v существует односторон­
вершиной v.

Если граф G имеет вершины со степенью не меньше 2, то граф содержит цикл

Связный граф G является эйлеровым тогда и
только тогда, когда степень каждой вершины
G
четна.

Связный граф является эйлеровым тогда и только тог­
да, когда его множество ребер может быть разбито на неnересекающиеся
циклы (без общих ребер).

Связный граф является полуэйлеровым тогда и только
тогда, когда у него есть ровно две вершины с нечетной степенью.

Заметим, что в полуэйлеровом графе любая полуэйлерова цепь должна
начинаться в одной из вершин с нечетной степенью, а завершаться
-
в дру­
гой. Заметим также, что, согласно лемме о рукопожатиях граф не может иметь
только одну вершину нечетной степени.

Если
G
является простым графом с п>=3 вершинами и если для каждой пары несмежных вершин,v и w,выполняется
соотношение
deg(v) + deg(w) >= п,
то граф G- гамильтонов.



----------деревья--------

Связный граф без циклов называется деревом

Пусть Т- граф сп вершинами. Тогда следующие утвержде­
ния эквивалентны:
1) Т-дерево;
2) Тне содержит циклов и имеет п - 1 ребер;
3) Т является связным и имеет п- 1 ребер;
4) Т является связным и каждое его ребро является мостом;
5) любые две вершины Т связаны ровно одним путем;
6) Т не содержит циклов, но добавление любого нового ребра
создает
ровно один цикл.


Остовное дерево графа — это дерево, подграф данного графа, с тем же числом вершин, что и у исходного графа. Неформально говоря, остовное дерево получается из исходного графа удалением максимального числа рёбер, входящих в циклы, но без нарушения связности графа.

Общее количество различных маркирован­
ных деревьев с п вершинами равно n в степени n-2

Количество остовных деревьев графа Кn равно n в степени n-2

Пусть
G -
связный граф с п вершинами. Тогда следующее
построение дает решение задачи о минимальном остовном дереве:
1) пусть е 1 -
2) определим
ребро
G
минимального веса;
е 2 , е 3 , ••• , еп_ 1 , выбирая на каждом этапе новое ребро
наименьшего возможного веса, которое не образует цикла с ранее вы­
бранными ребрами е;.
Искомое остовное дерево представляет собой подграф Т графа
G,
обра­
зованный ребрами е 1 , е 2 , ••• , еп- ~·


Существуют две хорошо известные процедуры поиска: поиск в глубину
(depth-first search)
и поиск в ширину
(breadth-first search).
Оба метода посеща­
ют все вершины, но в разном порядке.

При поиске в Иlирину мы выполняем ветвление по максимШlьно возмож11ому
количеству верИIИН, прежде чем идти в1лубь дерева.

При поиске в глубину, прежде чем переходить к другим вершинам, мы как
можно сильнее углубляемся в дерево.

Прямоугольный каркас со скобами является жестким тогда
и только тогда, когда соответствующий двудольный граф связен.



Планарный граф
(planar graph) -
это граф, который можно нарисовать на
плоскости без самопересечений, т.е. так, чтобы никакие два ребра геометричес­
ки не пересекались нигде, кроме как в вершине, которой оба они инцидент­
ны.

каждый простой УU1анарный граф может быть начерчен прямыми
линиями.


Граф является планарным тогда и только тогда, когда он не
содержит подграфа, стягиваемого к К 5 или Кз.з ·


Если
G -
счетный граф, каждый конечный подграф кото­
рого планарный, то граф
G также
является планарным.


Пусть G -
плоский чертеж связного планар­
ного графа и пусть n, m и f означают количество вершин, ребер и граней
графа
G соответственно.
Тогда
n-m+f=2.


Формула Эйлера может быть легко расширена для несвязных графов .
Пусть G - плоский граф с n вершинами, m ребрами, f гранями и k компонентами. Тогда n-m+f=k+1

Каждый простой планарный граф G содержит вершину,
степень которой не превышает 5.

РАСКРАСКА ГРАФОВ

Если
G- граф без петель, то G является k-раскрашиваемым (k-colouraЫe),
если мы можем назначить один из
k цветов каждой вершине таким образом,
чтобы смежные вершины имели разные цвета

Если G - простой граф, наибольшая степень вершины ко­
торого равна Дельта, то граф
G является (Дельта + 1)-раскрашиваемым.


Если G -
простой связный граф , не являю­
щийся полным, и наибольшая степень вершины в
G равна дельта = (>=3), то граф
G является Дельта-раскрашиваемым .

Каждый простой планарный граф является 4-раскраши­
ваемым.

Граф
G
является k-раскрашиваемым-(е) (или k-реберно-раскрашивае­
мым), если его ребра могут быть раскрашены
k
цветами так, чтобы никакие
два смежных ребра не были окрашены в одинаковый цвет.

Паросочетания, свадьбы, теорема Менгера.


Marriage condition - Для всех целых
k,
удовлетворяющих условию 1 <= k <= m, где m = 
общее ко­личество девушек, каждое множество из k девушек должно коллективно
дружить как минимум с k юношами.

Трансверсаль -  это множество, содержащее ровно один элемент из каждого множества из S. 

Пусть Е - непустое конечное множество и пусть F = (s1,s2,...sm) - семейство
непустых подмножеств E. Тогда F имеет трансверсаль тогда и только тогда,
когда объединение любых k подмножеств Si содержит как минимум k элементов
для 1 <= k <= m


Максимальное количество реберно-непересекающихся пу­
тей, соединяющих две различные вершины ,
v
и
w, связного
графа, равно
минимальному числу ребер в vw-разделяющем множестве.

Максимальное
число вершинно-непересека­
ющихся путей , соединяющих две различные несмежные вершины,
v
и
w,
графа , равно минимальному числу вершин в vw-отделяющем множестве.

----------------------------------------------------
Комбинаторика
----------------------------------------------------

Большинство комбинаторных задач решается с использованием двух правил:
-Правило суммы
-Правило произведения

Правило суммы гласит, что если А и В — несвязанные события, и существует n1 возможных исходов события A, и n2 возможных исходов события B, то возможное число исходов события «А или B» равно сумме n1 + n2 . 

Правило произведения утверждает, что если дана последовательность к событий с n1 возможными исходами первого, n2 - второго, и т. д., вплоть до nk возможных исходов последнего, то общее число исходов последовательности k событий равно произведению n1 * n2*…* nk.

В комбинаторике размеще́нием (из n по k) называется упорядоченный набор из k различных элементов из некоторого множества различных n элементов.

Размещение без повторений из n элементов по k находим по формуле:
n!/(n-k)!

Размещение с повторениями находим так: n в степени k.

В комбинаторике перестано́вка — это упорядоченный набор без повторений чисел 1,2, ... ,n, обычно трактуемый как биекция на множестве {1,2,...,n}, которая числу i ставит в соответствие i-й элемент из набора. Число n при этом называется длиной перестановки.

Число всех перестановок - n!

Перестановка с повторениями – это упорядоченная⟨n,k⟩ – выборка с повторениями, в которой элемент a1 повторяется k1 раз, элемент a2 повторяется k2 раз, и так далее, до последнего элемента as, который повторяется ks раз (s ≤ n). При этом k = k1 + k2 + ... + ks.

Число перестановок с повторениями ищем по формуле:
n!/n1!*n2!...*nk!

В комбинаторике сочетанием из n по k называется набор k элементов, выбранных из данного множества, содержащего n различных элементов.

Сочетание без повторений можно найти по формуле:
n!/(n-k)!*k!

Сочетанием с повторениями называются наборы, в которых каждый элемент может участвовать несколько раз.

Сочетание с повторениями можно найти по формуле сочетаний БЕЗ повторений:
n!/(n-k)!*k! , НО
в этом случае n будет равен (n+k-1)

Разбие́ние мно́жества — это представление его в виде объединения произвольного количества попарно непересекающихся непустых подмножеств.



ЛОГИКА

Под ВЫСКАЗЫВАНИЕМ понимают повествовательное предложение, относительно которого можно сказать, истинно оно или ложно.

Повествовательное предложение «Я лгу» не является высказыванием, поскольку если оно истинно (то есть я действительно лгу) – значит я не лгу, а говорю правду! И наоборот… Это пример ЛОГИЧЕСКОГО ПАРАДОКСА.

Операцию ДИЗ'ЮНКЦИЯ называют еще "логическим или". Если два высказывания соединить диз'юнкцией, то получится сложное высказывание которое истинно, если истинно хотя бы одно из входящих в него высказываний. То есть следует уточнить, что это "неисключающее или". Например, «Мы любим пиво или мы любим мороженое» истинное сложное высказывание, поскольку хотя бы одно из входящих в него элементарных высказываний истинно. А возможно, и оба. 

Операцию КОН'ЮНКЦИЯ называют еще "логическим и". Сложное высказывание будет истинно, если истинны оба входящих в него высказывания.

Операция ОТРИЦАНИЕ – "логическое не" – истинное высказывание превращает в ложное и наоборот.

ИМПЛИКАЦИЯ или "логическое если…, то". Например, «Если Наполеон родился в Кудымкаре, то газ при нагревании сужается». Это, кстати, истинное высказывание! Нет причин считать его ложным.
Единственная ситуация, когда импликация ложна, это когда посылка (часть «если») истинна, а следствие (часть «то») ложна.

Есть также ЛОГИЧЕСКАЯ ЭКВИВАЛЕНТНОСТЬ или "тогда и только тогда« (кстати, воспользовавшись»американским приемом", можно записать короче – "ттогда"). Результирующее сложное высказывание истинно, если одновременно истинны или ложны оба входящих в него высказывания.

ШТРИХ ШЕФФЕРА или логическое "и-не". Результат этой операции равносилен последовательному применению операций кон'юнкции и отрицания. Соответственно, результирующее высказывание будет ложным, только если входящие в него высказывания одновременно истинны. Штрих Шеффера – это операция замечательная тем, что ее одной (необходимое количество раз примененной) достаточно, чтобы записать любое сложное высказывание.

Если использовать только три первых логических операции: диз'юнкцию, кон'юнкцию и отрицание, то алгебра высказываний аналогична алгебре множеств. Аналог диз'юнкции – об'единение, кон'юнкции – пересечение, а отрицания – дополнение. Эти аналогии можно использовать для одного из возможных об'яснений смысла логических операций (это, так называемая, теоретико-множественная интерпретация – и она достаточно «естественна»). 

Импликацию можно представить иначе, если взять диз'юнкцию отрицания первого высказывания со вторым.

Для эквивалентности замена более длинная, но, фактически, совпадающая с определением. Например, высказывание (пусть и несколько диковатое):
Хорошая погода стоит ТОГДА И ТОЛЬКО ТОГДА, КОГДА мы купаемся" эквивалентно высказыванию "Хорошая погода И мы купаемся ИЛИ НЕхорошая погода И мы НЕ купаемся".

Штрих Шеффера для этих же исходных высказываний мог бы выглядеть следующим образом:
"НЕ ВЕРНО, что стоит хорошая погода И мы купаемся" или (по так называемому закону Де Моргана) это равносильно высказыванию:
"НЕхорошая погода ИЛИ мы НЕ купаемся".


В алгебре высказываний есть законы: коммутативный, ассоциативный и дистрибутивный, которые аналогичны законам для множеств.

Чтобы убить двух зайцев, для иллюстрации коммутативного закона воспользуемся примером из книги Клини «Математическая логика»: "Мэри вышла замуж И родила ребенка" равносильно с точки зрения логики тому что "Мэри родила ребенка И вышла замуж". Первый «заяц» связан c синтаксисом коммутативного закона – то есть можно переставлять местами высказывания, а второй «заяц» – с семантикой, при которой перестановка не соответствует общепринятой морали – для приличного общества существенно, какое событие стоит первым. (Это в очередной раз говорит о том, что математическая логика не учитывает [и не в состоянии это сделать!] многих нюансов, имеющих место в практике жизни).

Ассоциативный закон утверждает, что безразлично, в каком порядке мы рассматриваем (истинность) попарных кон'юнкций и диз'юнкций:
"Стоит хорошая погода И мы купаемся И заработали ангину".
"Стоит хорошая погода ИЛИ мы купаемся ИЛИ заработали ангину".


Дистрибутивный закон.
Приведем пример только для «экзотического» случая.
"Стоит хорошая погода ИЛИ мы купаемся И заработали ангину" равносильно высказыванию
"Стоит хорошая погода И мы купаемся ИЛИ стоит хорошая погода И заработали ангину"


Два сложных высказывания являются равносильными, если они имеют одинаковые ТАБЛИЦЫ ИСТИННОСТИ.


Формально предикатом называется функция, аргументами которой могут быть ПРОИЗВОЛЬНЫЕ ОБ'ЕКТЫ из некоторого множества, а значения функции «истина» или «ложь». Предикат можно рассматривать как расширение понятия высказывания.

Пример. Вместо трех высказываний
«Маша любит кашу»
«Даша любит кашу»
«Саша любит кашу» можно написать один предикат
«Икс любит кашу» и договориться, что вместо неизвестного Икс могут быть либо Маша, либо Даша, либо Саша.

Для предикатов справедливы, и имеют тот же смысл, ранее рассмотренные логические операции. Например,
"ЕСЛИ Маша любит кашу, ТО Саша любит кашу".
Но есть и две новые операции, специфические. Они называются несколько вызывающе – операциями НАВЕШИВАНИЯ КВАНТОРОВ. Эти операции соответствуют фразам «для всех» – квантор общности и «некоторые» – квантор существования. 

предикаты могут быть не только одноместные. Это просто проиллюстрировать, если представить, что дети могут любить не только кашу… «Икс любит Игрека» – двухместный предикат. "ВСЕ любят Игрека" – одноместный предикат. "ВСЕ любят КОЙ-КОГО [некоторого]" – нульместный предикат, то есть высказывание.

ИЗ ФОРМАЛИЗОВАННЫХ ЯЗЫКОВ МАТЕМАТИКИ ЯЗЫК ПРЕДИКАТОВ – САМЫЙ БЛИЗКИЙ К ЕСТЕСТВЕННОМУ. Поэтому работы по искусственному интеллекту тяготеют к использованию этого языка. В сравнении с естественным, это очень во многих смыслах ограниченный язык. Но лучшего за 100 лет не придумано, если не считать так называемого «синтаксического сахара», когда вместо соответствующей символики используются, например, слова естественного языка. (Вроде того, как мы пытаемся это делать).


ДЕДУКТИВНЫЙ подход, называемый еще АКСИОМАТИЧЕСКИМ, это подход от общего к частному. От аксиом (постулатов) к теоремам (следствиям). Аксиоматическая теория строго задана, если строго сформулирован (задан) язык теории, ее аксиомы и правила вывода.

Пожалуй самым фундаментальным открытием в этой сфере следует считать доказанную Геделем ТЕОРЕМУ О НЕПОЛНОТЕ. Оказывается, в сколько-нибудь сложной аксиоматической системе (посложнее, чем кубики, но достаточно даже арифметики) существуют формулы, которые нельзя ни доказать, ни опровергнуть.


Теория алгоритмов не учит «составлять» алгоритмы. Она занимается более важным вопросом. Основная задача классической теории алгоритмов – это ответ на вопрос: «Можно ли (вообще) для задач данного типа построить алгоритм?». Говоря более наукообразно: «Являются ли задачи данного типа алгоритмически разрешимыми»?

понятие АЛГОРИТМА относится к фундаментальным неопределяемым понятиям. В вопросе об алгоритме у нас собачья позиция. Понимать понимаем, а сказать не можем. Если где-то встречаете «определение» алгоритма, то там, что ни слово – то аллегория…

Из этого тупика был найден нетривиальный выход. Понятие алгоритма заменили строго формализованными математическими моделями. Среди самых известных рекурсивные функции, машины Тьюринга и нормальные алгорифмы Маркова.

Эти математические модели выступают в роли «конкретизаций понятия алгоритма». То есть длительная практика подтверждает так называемый тезис Черча, который можно пересказать так:
Для любой алгоритмически разрешимой задачи можно построить рекурсивную функцию (машину Тьюринга, нормальный алгорифм Маркова). И наоборот, для задач, для которых нельзя построить перечисленные конкретизации, не существует алгоритма решения.

РЕКУРСИВНЫЕ ФУНКЦИИ основаны на той идее, что исходные данные и возможные результаты решения любой задачи можно пронумеровать. Для чего, естественно, достаточно множества натуральных чисел (целых положительных чисел, начиная с нуля). А далее базовыми об'являются функции, возможность выполнить (вычислить) которые не вызывает сомнений.

НУЛЬ– ФУНКЦИЯ – это функция, которая дает значение ноль для любого значения аргумента. Реализовать эту функцию может не только ребенок. Можно посадить попугая и подучить его на любой вопрос о значении функции кричать «Ноль!».

ФУНКЦИЯ СЛЕДОВАНИЯ дает следующее, по сравнению с аргументом, значение. Для пяти это шесть, для миллиона – миллион один. Можно бы было сказать, что здесь надо просто прибавлять 1.
Но операции сложения у нас пока нет!

ФУНКЦИЯ ВЫБОРА АРГУМЕНТА. Это вообще забавная даже для первоклассника функция, содержащая в своем имени номер аргумента. Если у вас есть несколько аргументов, то эта функция в качестве значения возьмет значение указанного в ней аргумента. Например, функция выбора третьего из Иванова, Петрова и Сидорова, которых мы ранее пронумеровали, например, как 22, 13 и 49, даст значение 49.

Эти три базовых функции могут использоваться далее в качестве исходного материала для создания более сложных функций с помощью трех операторов: суперпозиции, примитивной рекурсии и наименьшего корня.
Известный хорошо еще со школы ОПЕРАТОР СУПЕРПОЗИЦИИ позволяет вместо аргумента подставлять функцию… «Игла в яйце, а яйцо в ларце»…

Дольше словами описывать ОПЕРАТОР ПРИМИТИВНОЙ РЕКУРСИИ. Но если поднатужиться, то можно понять. Этот оператор позволяет построить новую функцию из двух функций, одна из которых имеет на один аргумент меньше, а другая на один аргумент больше.
Значение создаваемой функции для нулевого значения выбранного аргумента приравнивается к функции, не имеющей как раз этого аргумента. Значение же создаваемой функции для всех прочих
(ненулевых) значений выбранного аргумента приравнивается другой функции, зависящей (напрягитесь!) от тех же аргументов, кроме выбранного; от ПРЕДЫДУЩЕГО значения выбранного аргумента и от создаваемой функции от предыдущего значения выбранного аргумента.
Приведем построение с помощью рекурсии всем известной двухместной функции умножения икс на игрек (считая выбранной переменной игрек).
Функцию умножения икс на ноль можно выразить через нуль-функцию от икс, которая обеспечит нам желанное значение – ноль.
Функцию умножения икс на игрек (отличный от нуля) можно выразить через функцию сложения икса со значением функции умножения икса на предыдущее значение игрека… То есть мы выразили умножение через сложение.

Последний оператор – ОПЕРАТОР НАИМЕНЬШЕГО КОРНЯ. Его необходимость просто об'яснить хотя бы тем, что рекурсивные функции, призванные решать любые алгоритмически разрешимые задачи, сами используют лишь целые положительные числа. А это не позволяет решить даже детскую задачку: 5 – 8 =? (Нет для рекурсивных функций отрицательных чисел). На самом-то деле эти детские задачки можно решить по-детски. Договориться, что 1000 это (сдвинутый) ноль, а вычитание – есть сложение с «отрицательным» числом! Тогда
1005 + 992 = 1997 (приведение к шкале: 1997 – 1000 = 997)
Поскольку мы при этом сдвиг нуля учли дважды, то окончательный результат (в системе с один раз сдвинутым на 1000 нулем) будет 997. Но это детское решение лишь говорит о том, что без отрицательных чисел и в школе можно обойтись. Как и в древнем Риме обходились. Правда там и без нуля обходились, а здесь он нам нужен позарез.
Именно оператор наименьшего корня и следит, при каком значении выбранного аргумента наблюдаемая им функция впервые опустится до нуля. Это значение выбранного аргумента и будет значением оператора наименьшего корня. Например, для функции икс минус игрек при иксе равном 5, значение оператора наименьшего корня также будет равно 5, поскольку двигаясь в значениях игрека от нуля получим нулевое значение функции именно при игрек равном 5.

Базовые функции и функции, которые могут быть построены из них с помощью операторов суперпозиции, примитивной рекурсии и наименьшего корня, образуют множество ЧАСТИЧНО-РЕКУРСИВНЫХ ФУНКЦИЙ. А множество частично-рекурсивных функций совпадает с множеством всех алгоритмически разрешимых задач (множеством всех вычислимых функций). Кстати, за слово «частичные» надо благодарить оператор наименьшего корня, из-за которого в множество построенных функций входят и не всюду определенные (частичные) функции.

В машине Тьюринга есть устройство управления, имеющее память «состояний» и работающее по задаваемой программе (алгоритму). Программа состоит из команд. Каждая «команда» состоит в следующем: Машина читает символ из ячейки, против которой стоит головка (находясь в каком-то состоянии [вначале – в начальном]), записывает в эту ячейку символ (может и тот же самый), меняет свое состояние (может сохранить прежнее) и делает шаг влево или вправо (может остаться на месте).
Так Машина ходит вдоль ленты до тех пор, пока не перейдет в специальное состояние, называемое заключительным. Это говорит об окончании работы Машины (алгоритма). А на ленте остается результат (решения).
Несмотря на внешнюю примитивность такой конструкции, для любой алгоритмически разрешимой задачи можно построить Машину Тьюринга!

Смысл нормальных алгорифмов – принудительный обмен, порядок которого жестко задан. Собственно алгоритм в нормальных алгорифмах задается НОРМАЛЬНОЙ СХЕМОЙ ПОДСТАНОВОК – очередностью правил «что на что менять». Лучше всего это показать на примере замены слов, тем более, что и сам Марков любую и неизвестное, последнюю определим как ту, которая стоит ПЕРЕД пустым символом. Это главная идея данного решения. Остальное – дело техники. Напишем программу – четыре команды.
Машина читает пустой символ, находясь в начальном состоянии пишет пустой символ и делает шаг вправо. (Значит машина находится ДО начала последовательности единичек)
Машина читает единичку, находясь в начальном состоянии, пишет единичку и делает шаг вправо, оставаясь в этом состоянии. (Значит машина «идет» по последовательности единичек)
Машина читает пустой символ, находясь в начальном состоянии, пишет пустой символ, делает шаг влево и переходит во второе состояние. (Значит найдена последняя единичка)
Машина читает единичку, находясь во втором состоянии, пишет пустой символ (стирает единичку), стоит на месте и переходит в заключительное состояние. (Задача решена)
Несмотря на внешнюю примитивность такой конструкции, для любой алгоритмически разрешимой задачи можно построить Машину Тьюринга! А поскольку машина строится в собственной голове, вопросы «технической эффективности» такой машины никакой роли не играют. Единственный вопрос. Доберется ли машина до заключительного состояния? Пусть и через (воображаемый) миллион лет. Тогда задача разрешима!

Не будет преувеличением сказать, что нормальные алгорифмы Маркова создал А.А.Марков, член-корреспондент Академии Наук СССР из Москвы. Для восстановления единообразия, по праву автора, он назвал алгориТмы алгориФмами, поскольку слово это арабо-греческое, как и слово ариФметика…
Смысл нормальных алгорифмов – принудительный обмен, порядок которого жестко задан.
Собственно алгоритм в нормальных алгорифмах задается НОРМАЛЬНОЙ СХЕМОЙ ПОДСТАНОВОК – очередностью правил «что на что менять». Лучше всего это показать на примере замены слов, тем более, что и сам Марков любую последовательность букв, какую ни в одном словаре не сыщешь, называл «словами». Так при наличии двух подстановок: меняющей «ха» на «ссон» и «мусс» на «сл» из «муха» можно сделать «слон».
Механизм нормальных алгоритмов настолько прост, что напоминает скорее детскую игру, чем математику. Но на самом деле это очень мощный механизм, поскольку через него можно выразить решение любой алгоритмически разрешимой задачи. И опять напомним, что это не следует воспринимать, как предложение решать любую задачу через подстановки (хотя на этих принципах работает замечательный язык программирования РЕФАЛ). Это лишь означает, что любую алгоритмически разрешимую задачу МОЖНО представить в виде такой системы подстановок. А если нельзя (и вы это смогли доказать), то такая задача вообще не имеет алгоритма решения.

Формальные грамматики – это хорошо развитый математический аппарат, позволяющий, кроме изучения «высоких материй», (математически) грамотно создавать языки программирования и писать компиляторы для этих языков.

Между естественными и формальными языками непреодолимая пропасть. Поэтому совпадение терминологии лучше считать случайным… Тем более, в рамках многогранного и разветвленного ЯЗЫКА МАТЕМАТИКИ раздел формальных грамматик и языков ориентирован прежде всего на проблемы построения компиляторов.

Формальный язык можно задать как некое множество слов. Слово, это последовательность символов. Любая компьютерная программа в этом случае тоже воспринимается как слово.

Словами данного языка может быть далеко не любая абракадабра, доступная клавиатуре. А только лексически и синтаксически (безупречно!) правильные программы. Безупречная с точки зрения грамматики программа может быть бесполезной, бессмысленной или даже вредной. Но за правильную работу программы формальная грамматика и компилятор не отвечают.

Для того, чтобы задать грамматику, надо задать множества ТЕРМИНАЛЬНЫХ и НЕТЕРМИНАЛЬНЫХ символов. Терминальные символы это символы используемые в языке. Нетерминальные (промежуточные) символы – это символы, используемые в создании (порождении) слов языка. А создаются слова по грамматическим правилам. 

И каждое слово, напомним, это с точки зрения программиста – программа, записанная исключительно терминальными символами. Далее задаются ГРАММАТИЧЕСКИЕ ПРАВИЛА. Они очень напоминают подстановки в алгорифмах Маркова. Но в отличие от последних порядок применения грамматических правил произвольный. Применение правила заключается в замене в преобразуемой строке какой-то последовательности символов, совпадающей с левой частью какого-то правила, правой частью (последовательностью символов) этого правила.

Введем в оборот из чисто эстетических соображений еще один красивый термин – СЕНТЕНЦИАЛЬНАЯ ФОРМА. Дело в том, что при построении программ в формальных грамматиках всегда танцуют от одного начального нетерминального символа. Обозначим этот символ «программа». Вместо этого символа по одному из грамматических правил происходит подстановка соответствующей правой части, которая может содержать последовательность из каких-то нетерминальных и терминальных символов. Кстати, такой процесс называется НЕПОСРЕДСТВЕННЫМ ПОРОЖДЕНИЕМ. Любой их появившихся нетерминальных символов может быть заменен по подходящему грамматическому правилу какой-то цепочкой символов. То есть начальный нетерминальный символ «программа» последовательно превращается во все более длинную цепочку символов. И так вплоть до того момента, когда в последовательности символов останутся только терминальные символы. То есть будет получено слово данного языка (по иронии судьбы называемое ПРЕДЛОЖЕНИЕМ). Все последовательности символов, которые в процессе непосредственных порождений находятся между начальным нетерминальным символом и конечным предложением и называются сентенциальными формами. А нам остается радоваться, что английский язык нам неродной.

Компилятор, получив программу, выполняет обратную работу. Пред'явленное предложение он свертывает по грамматическим правилам (теперь двигаясь от правой части правила к левой) начального символа «программа».

Есть достаточно грубая, но, все равно, полезная в первом приближении классификация грамматик, принадлежащая Хомскому.

Грамматики первого типа называют КОНТЕКСТНО-ЗАВИСИМЫМИ (или просто КЗ). В большинстве случаев разумно принять общее ограничение, что правило заменяет строго один нетерминальный символ. Отличительная особенность КЗ–правил в том, что замена нетерминального символа на строку допускается, когда этот символ находится в некотором окружении других символов (в контексте). Например, нетерминальный символ «оператор» может быть заменен на нетерминальный символ «пустой оператор», если в преобразуемой строке перед символом «оператор» был другой символ, за которым непосредственно следовал «оператор». А иначе такую замену делать нельзя.
Представьте например, правило официанта. Осуществлять замену грязной тарелки на выписанный счет можно при наличии опустошенного бокала. В другом контексте (при полном бокале [граненом стакане] рядом) вместо грязной тарелки клиенту предлагается новая закуска.

Грамматики второго типа называют КОНТЕКСТНО-СВОБОДНЫМИ (или просто КС). Каждое правило может применяться без оглядки на контекст. Вместо грязной тарелки – новая закуска (без всяких дополнительных условий)… Грамматики разных типов могут порождать один и тот же язык. Компиляторы диктуют требование приводить грамматику к типу КС. Обычно в рамках уже этого типа накладываются дополнительные ограничения, что позволяет существенно упростить грамматический разбор в компиляторе.

Грамматики последнего третьего типа называются АВТОМАТНЫМИ или РЕГУЛЯРНЫМИ. Это связано с тем, что они порождаются и распознаются автоматами (эту математическую модель ассоциируют не с Калашниковым, а с фамилиями математиков-логиков Мили Мура Трахтенбротта и т. п.) и регулярными выражениями (это, как и в регулярной армии – выражения строятся по простым правилам и просто распознаются – это тоже математическая модель).
Обычно автоматные грамматики используются на уровне лексики. Лексема, в обычном понимании – это словарная единица. Тем ни менее, с точки зрения компилятора это «символ», коль скоро «словом» будет вся программа. В данном случае, например, 345.08 может быть распознан как один символ – действительное число.
Лексический анализ в компиляторе предшествует синтаксическому анализу… Существуют знаменитые команды UNIXlex и yacc, который позволяют автоматизировать процесс написания лексического и синтаксического анализаторов компилятора.










ТЕОРИЯ ВЕРОЯТНОСТЕЙ


Опытом, или исnьiтанием, называют всякое осуществление определенного комплекса условий или действий, при которых происходит
соответствующее явление. 

Возможный результат опыта называют событием.

Событие называется достоверны.м в данном опыте, если оно обязательно про изойдет в этом опыте. Например, если в ящике находятся
только голубые шары, то событие "из ящика извлечен голубой шар" является достоверным (в ящике нет шаров другого цвета). 

Событие называется невозможным в данном опыте, если оно не
может произойти в этом опыте. Так, если в ящике находятся только
красные шары,ТО событие "из ящика извечен голубой шар" является
невозможным (таких шаров в ящике нет). 

Событие называется случайным в данном опыте, если оно может
произойти, а может и не произойти в этом опыте. Например, если в
ящике находятся n голубых и т красных шаров, одинаковы по размеру и
весу, то событие "из урны извлечен голубой шар" является случайным
(оно может произойти, а может и не произойти, поскольку в урне имеются не только голубые, но и красные шары). 

Два события называются совместными в данном опыте, если появление одного из них не исключает, появление другого в этом опыте. Так,
при подбрасывании двух симметричных монет, события А - "герб на
верхней стороне первой монеты" и В - "цифра на верхней стороне второй монеты" являются совместными. 

Два события называются несовместными, если они не могут произойти вместе при одном и том же испытании. Например, несовместными являются попадание и промах при одном выстреле.

Несколько событий называются несовместными, если они попарнонесовместны. 

Два события называются противоположными, если появление од­
ного из них равносильно непоявлению другого. Так, противоположными
являются события "герб" и "цифра" при одном подбрасывании симмет­
ричной монеты.

Множество событий от А1 до Аn - полная группа событий, если они попарно несовместны

События считают равновозможными, если нет оснований полагать,
что одно событие является более возможным, чем другие. Например,
при подбрасывании монеты

Каждое событие, которое может наступить в итоге опыта, называет­
ся элементарным исходом (элементарным событием,
или шансом).

Элементарные исходы, при которых данное событие наступает, на­
зьmаются благоприятствующими этому событmo, или благоприятными
шансами.

Верояmносmью события называется отношение числа элементарных
исходов, благоприятствующих данному событию, к числу всех равновозможных исходов опыта в котором может появиться это событие. 


Вероятность достоверного события равна единице. 

Вероятность невозможного события равна нулю.

Вероятность случайного события выражается положительным
числом, меньшим единицы

Вероятность ЛЮБОГО события больше или равна 0 или меньше или равна 1





АЛГОРИТМЫ

Алгоритм в наиболее общем виде - “набор шагов для выполнения задачи”.

Корректность – свойство алгоритма, заключающееся в способности алгоритма давать правильные результаты при различных исходных данных.

Под приближенными алгоритмами (решениями) понимаются такие алгоритмы для решения комбинаторных задач, которые возвращают вариант, отличающийся от оптимального не более, чем на определённую погрешность. 

Эффективность алгоритма — это свойство алгоритма, которое связано с вычислительными ресурсами, используемыми алгоритмом. Алгоритм должен быть проанализирован с целью определения необходимых алгоритму ресурсов. Эффективность алгоритма можно рассматривать как аналог производственной производительности повторяющихся или непрерывных процессов.

Время - основной показатель эффективности алгоритма.

Ещё показатели: 
- количество памяти, требуемой алгоритму для работы
- сетевые соединения
- дисковые операции и т.п.

В отличие от корректности алгоритма, которая не
зависит от конкретного компьютера, выполняющего алгоритм, фактическое время работы
алгоритма зависит от нескольких факторов, внешних по отношению к самому алгоритму:

-скорость работы пк
-язык программирования
-компилятор\интерпретатор
-опыт программиста
-параллельные задачи, выполняемые на пк и т.п.

Обычно предполагается, что алгоритм выполняется на 1 компьютере и все необходимые данные находятся в его оперативной памяти.

Оценка скорости алгоритма происходит с помощью объединения 2-х идей:
- нужно определить как зависит время работы алгоритма от размера его входных данных
-нужно определить как быстро с ростом размера входных данных растет время работы алгоритма (скорость роста времени работы)


Самое интересное в нашем подходе то,
что нас интересует только доминирующий член функции времени работы алгоритма, и
при этом мы не учитываем коэффициенты.

например, если мы определили, что алгоритм для решения задачи использует 20n^3+100n^2+300n+200 тактов процессора, то мы говорим, что его время работы растет с ростом входных данных как n^3.


Если мы ищем книгу Шолохова, начиная с левого конца полки и проверяя поочередно
все книги слева направо, такой метод называется линейным поиском.


Асимптотические обозначения позволяют оценить время время работы алгоритма,
являясь наглядной характеристикой его эффективности. Также позволяют сравнить
производительность различных алгоритмов. Например производительность алгоритма
сортировки методом слияний со временем работы
O(lgN)
выше производительности
алгоритма сортировки вставкой, время работы которого в наихудшем случае составляетO(n^2).


Для подтверждения правильности работы алгоритма (то есть, что он выдает верные результаты для любого множества входных данных) существует масса методов. Например:

	Один из распространенных методов показа правильности алгоритма использует 
	инвариант цикла: утверждение, для которого мы демонстрируем истинность в начале каждой
	итерации цикла. Чтобы инвариант цикла мог помочь доказать корректность алгоритма, мы
	должны показать выполнение трех его свойств:
	
	- Инициализация. Инвариант цикла истинен перед первой итерацией цикла.
	- Сохранение. Если инвариант цикла истинен перед итерацией цикла, он остается 
истинным и после нее.
	- Завершение. Цикл завершается, а после его завершения инвариант цикла вместе с 
причиной завершения цикла дают нам искомую цель работы алгоритма.

Инвариа́нт или инвариа́нтность — термин, обозначающий нечто неизменяемое. 
	

С помощью рекурсии мы решаем задачу путем решения меньших экземпляров этой же задачи.

Чтобы рекурсия работала, должны выполняться два свойства. Во-первых, должен 
существовать один или несколько базовых случаев, когда вычисления проводятся 
непосредственно, без рекурсии. Во-вторых, каждый рекурсивный вызов процедуры должен быть
меньшим экземпляром той же самой задачи, так что в конечном итоге будет достигнут
один из базовых случаев.

Сортировка — важная задача сама по себе, а не только как шаг предварительной 
обработки данных для бинарного поиска.

В дополнение к 
ключу (который при сортировке мы будем называть ключом сортировки) сортируемые 
элементы обычно содержат некоторую информацию, которую мы называем 
сопутствующими данными. Сопутствующие данные представляют собой информацию, которая связана
с ключом сортировки и перемещается при перемещении элементов вместе с ключом. В 
нашем примере с книжной полкой ключом сортировки является фамилия автора, а сопутствующими данными - книга.

В мире компьютерных алгоритмов
сортировка означает размещение элементов в некотором строго определенном порядке, а
“систематическая организация в группах” называется “группировкой”.

Двоичный (бинарный) поиск (также известен как метод деления пополам или дихотомия) — классический алгоритм поиска элемента в отсортированном массиве (векторе), использующий дробление массива на половины.

Есть несколько алгоритмов сортировки массивов:

-Сортировка выбором
Сортировка выбором — это алгоритм сортировки массивов, в котором на каждой итерации во всей последовательности неотсортированных данных выбирается минимальный элемент (при сортировке по возрастанию) и помещается в первую позицию неотсортированной последовательности.

-Сортировка вставкой
Сортировка вставками (англ. Insertion sort) — алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов.

-Сортировка слиянием
Сортировка слиянием (англ. merge sort) — алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке. Эта сортировка — хороший пример использования принципа «разделяй и властвуй». Сначала задача разбивается на несколько подзадач меньшего размера. Затем эти задачи решаются с помощью рекурсивного вызова или непосредственно, если их размер достаточно мал. Наконец, их решения комбинируются, и получается решение исходной задачи.

-Быстрая сортировка
Быстрая сортировка, сортировка Хоара (англ. quicksort), часто называемая qsort (по имени в стандартной библиотеке языка Си) — алгоритм сортировки, разработанный английским информатиком Тони Хоаром во время его работы в МГУ в 1960 году.

Один из самых быстрых известных универсальных алгоритмов сортировки массивов: в среднем O(n*log n) обменов при упорядочении n элементов; из-за наличия ряда недостатков на практике обычно используется с некоторыми доработками.




